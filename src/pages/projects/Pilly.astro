---
import Layout from '../../layout/Layout.astro';

const project = {
  title: "Pilly",
  tagline: "Hardware-accelerated 2D game engine built on SDL3 with sprite-based rendering and physics.",
  date: "2024",
  role: "Engine Developer",
  repoUrl: "https://github.com/crowmoed/Pilly---C",
  stack: ["C++", "SDL3", "STB Image", "CMake", "OpenGL/Metal/D3D (via SDL3)"]
};

const githubIcon = `
<svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
  <path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.05-.015-2.07-3.345.72-4.05-1.605-4.05-1.605-.54-1.38-1.335-1.755-1.335-1.755-1.095-.75.09-.735.09-.735 1.215.09 1.845 1.245 1.845 1.245 1.08 1.845 2.835 1.305 3.525.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.225 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405 1.02 0 2.04.135 3 .405 2.295-1.545 3.3-1.23 3.3-1.23.66 1.695.24 2.925.12 3.225.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.285 0 .315.225.69.825.57A12.02 12.02 0 0 0 24 12c0-6.63-5.37-12-12-12z"/>
</svg>`;
---

<Layout>
  <div class="projects-wrapper back">
    
    <div class="detail-container">
      
      <header class="detail-header fade-in">
        <a href="/projects" class="back-link">
          <span class="arrow">←</span> All Projects
        </a>
        <h1>{project.title}</h1>
        <p class="tagline">{project.tagline}</p>
      </header>

      <div class="content-grid fade-in-delay">
        
        <main class="project-body">
          <div class="project-hero-image">
             <div class="placeholder-overlay">Sprite Physics Demo with Drag Interaction</div>
          </div>

          <div class="text-content">
            <h3>Overview</h3>
            <p>
              Pilly is a lightweight 2D game engine built on SDL3's hardware-accelerated rendering abstraction. It provides sprite management, Euler-integrated physics with gravity, AABB collision detection, and an event-driven input system. The project served as an exploration of low-level graphics programming and game engine architecture fundamentals.
            </p>

            <h3>SDL3 Rendering Backend</h3>
            <p>
              The engine uses SDL3's unified renderer abstraction, which maps to platform-specific graphics APIs: Metal on macOS, Direct3D 11/12 on Windows, and Vulkan on Linux. Window and renderer are created together via <code>SDL_CreateWindowAndRenderer()</code>, returning both handles in a single call.
            </p>
            <p>
              SDL3 introduced breaking API changes from SDL2 that the codebase adopts: <code>SDL_RenderTexture()</code> replaces <code>SDL_RenderCopy()</code>, <code>SDL_EVENT_*</code> constants replace <code>SDL_*</code> event names, and <code>SDL_CreateSurfaceFrom()</code> uses type-safe <code>SDL_PixelFormat</code> enums instead of SDL2's <code>Uint32</code> format constants. Rendering uses <code>SDL_FRect</code> (floating-point rectangles) for sub-pixel positioning capability.
            </p>

            <h3>Image Loading Pipeline</h3>
            <p>
              Texture loading integrates <strong>STB Image</strong> (single-header library) for format support across JPEG, PNG, BMP, and TGA. The pipeline:
            </p>
            <ul>
              <li><code>stbi_load()</code> returns CPU-side RGBA/RGB pixel buffer with channel count</li>
              <li>Pixel format determined dynamically: 4 channels → <code>SDL_PIXELFORMAT_RGBA32</code> (32-bit), 3 channels → <code>SDL_PIXELFORMAT_RGB24</code> (24-bit)</li>
              <li>Pitch (byte stride per scanline) calculated as <code>width × channels</code></li>
              <li><code>SDL_CreateSurfaceFrom()</code> wraps raw pixels in CPU-side <code>SDL_Surface</code></li>
              <li><code>SDL_CreateTextureFromSurface()</code> uploads to GPU VRAM</li>
              <li>Immediate cleanup of CPU resources (surface + raw pixels via <code>stbi_image_free()</code>)—texture persists in GPU memory</li>
            </ul>
            <p>
              Path resolution uses a multi-path fallback array to handle different working directory contexts (build dir vs project root), short-circuiting on first successful load.
            </p>

            <h3>Memory Management</h3>
            <p>
              The engine uses a raw pointer ownership model. Each sprite owns its <code>SDL_Texture*</code>, destroyed in the destructor. A global <code>std::list&lt;sprite*&gt;</code> maintains non-owning references for iteration during collision checks and rendering.
            </p>
            <p>
              Sprites are stack-allocated in <code>main()</code>, ensuring deterministic destruction order (reverse construction). However, the constructor has a side-effect: it mutates the shared sprite list via <code>objects.push_back(this)</code> and stores a pointer to the list for O(n) collision iteration. This pattern, while functional, violates single responsibility and creates dangling pointer risk if sprites are destroyed before loop termination.
            </p>

            <h3>Physics: Euler Integration</h3>
            <p>
              Gravity uses explicit Euler integration—the simplest (and least accurate) method:
            </p>
            <ul>
              <li>Position updated by accumulated velocity each frame</li>
              <li><code>acceleration</code> (actually velocity, misnomer preserved) increments by 1 pixel/frame² when above ground</li>
              <li>Ground detection: checks if <code>(y + height) ≥ windowHeight - 1</code>, with 1-pixel tolerance</li>
              <li>Collision response: sets <code>acceleration = 0</code>, stopping fall immediately (no bounce, no energy transfer)</li>
            </ul>
            <p>
              <strong>Critical limitation:</strong> No delta time multiplication. Physics is frame-rate dependent—at 60 FPS gravity is 1 px/frame², but if frame rate drops, falling slows proportionally. Velocity Verlet or RK4 would provide stability at larger timesteps, but Euler suffices for this simple system.
            </p>

            <h3>Collision Detection: AABB</h3>
            <p>
              Collision uses the <strong>Separating Axis Theorem</strong> simplified for axis-aligned bounding boxes. For AABBs, only two axes need testing (x and y). The <code>touching_object()</code> method checks four conditions:
            </p>
            <ul>
              <li>This sprite entirely left of target: <code>des_x + width ≤ target_x</code></li>
              <li>This sprite entirely right of target: <code>des_x ≥ target_x + target_width</code></li>
              <li>This sprite entirely above target: <code>des_y + height ≤ target_y</code></li>
              <li>This sprite entirely below target: <code>des_y ≥ target_y + target_height</code></li>
            </ul>
            <p>
              If any condition is true, a separating axis exists and there's no collision. The system uses <strong>predictive detection</strong>—testing the proposed destination position before moving, preventing tunneling but creating "sticky" behavior where sprites can't slide along surfaces.
            </p>
            <p>
              <strong>Complexity:</strong> <code>move_to()</code> iterates the entire sprite list: O(n) per movement. With each sprite potentially moving each frame, worst-case is O(n²) per frame. No spatial partitioning (quadtree, grid hash, sweep-and-prune) is implemented.
            </p>

            <h3>Event System</h3>
            <p>
              Input uses SDL's polling loop pattern, draining the event queue each frame:
            </p>
            <ul>
              <li><strong>Broadcast pattern:</strong> Every sprite receives every event via <code>event_update()</code>—no filtering or targeting. Inefficient for large sprite counts, but simple.</li>
              <li><strong>Mouse drag:</strong> On <code>SDL_EVENT_MOUSE_BUTTON_DOWN</code>, hit-test against sprite bounds. If hit, store grab offset (click position relative to sprite origin) to prevent snapping. While dragged, sprite follows mouse position minus offset.</li>
              <li><strong>Continuous update:</strong> Drag movement executes every event poll while dragged, not just on mouse move events—redundant updates when mouse is stationary.</li>
            </ul>

            <h3>Rendering Pipeline</h3>
            <p>
              Each frame follows the standard double-buffered pattern:
            </p>
            <ul>
              <li><strong>Clear:</strong> <code>SDL_RenderClear()</code> fills backbuffer with draw color</li>
              <li><strong>Draw:</strong> Multiple <code>SDL_RenderTexture()</code> calls build the command buffer. Integer positions converted to <code>SDL_FRect</code> floats at render time. Source rectangle is <code>nullptr</code> (full texture); non-null would enable sprite sheet tiling.</li>
              <li><strong>Present:</strong> <code>SDL_RenderPresent()</code> swaps backbuffer to front, submits GPU commands</li>
            </ul>
            <p>
              Render order is determined by sprite list iteration order—no z-ordering, depth sorting, or layering system. Last sprite rendered appears on top.
            </p>

            <h3>Frame Timing</h3>
            <p>
              Timing uses a simple <code>SDL_Delay(16)</code> for ~60 FPS target. This is a <strong>fixed sleep</strong>, not a proper timestep—actual frame time includes event processing, O(n²) collision checks, rendering, and OS scheduling jitter. Frame rate fluctuates below 60 FPS under load.
            </p>
            <p>
              Proper implementation would use <code>SDL_GetPerformanceCounter()</code> to measure actual elapsed time and apply delta time to physics calculations, decoupling simulation rate from frame rate.
            </p>

            <h3>Threading Model</h3>
            <p>
              Single-threaded: all logic runs on the main thread. SDL's event queue is thread-safe but unexploited here. No worker threads for physics, rendering, or asset loading. GPU parallelism occurs naturally—SDL3's renderer submits commands asynchronously, and <code>SDL_RenderPresent()</code> may block waiting for vsync while the GPU executes in parallel.
            </p>

            <h3>Platform Build Configuration</h3>
            <p>
              CMake handles cross-platform builds with platform-specific paths:
            </p>
            <ul>
              <li><strong>macOS:</strong> Links against Homebrew's ARM64 prefix (<code>/opt/homebrew</code>) for SDL3</li>
              <li><strong>Windows:</strong> Hard-coded absolute path to SDL3 MinGW distribution with post-build command to copy <code>SDL3.dll</code> to executable directory</li>
            </ul>
            <p>
              The hard-coded paths are brittle—should use <code>find_package(SDL3)</code> or environment variables for portability.
            </p>

            <h3>Known Limitations & Technical Debt</h3>
            <ul>
              <li><strong>O(n²) collision:</strong> No spatial partitioning, cache-unfriendly pointer chasing through <code>std::list</code></li>
              <li><strong>Frame-dependent physics:</strong> Behavior changes with frame rate</li>
              <li><strong>No delta time:</strong> Assumes constant 60 FPS</li>
              <li><strong>Dangling pointer risk:</strong> Sprite list stores raw pointers without lifetime tracking</li>
              <li><strong>No sprite batching:</strong> Each sprite issues separate draw call (GPU overhead)</li>
              <li><strong>No texture atlas:</strong> Identical images loaded separately, wasting VRAM</li>
              <li><strong>Synchronous asset loading:</strong> Blocks main thread during image decode</li>
              <li><strong>No error recovery:</strong> Failed texture loads leave sprite in invalid state</li>
            </ul>
          </div>
        </main>

        <aside class="project-sidebar">
          
          <div class="meta-block">
            <span class="meta-label">Role</span>
            <span class="meta-value">{project.role}</span>
          </div>

          <div class="meta-block">
            <span class="meta-label">Timeline</span>
            <span class="meta-value">{project.date}</span>
          </div>

          <div class="meta-block">
            <span class="meta-label">Technologies</span>
            <div class="tech-stack-wrap">
              {project.stack.map(tech => (
                <span class="tech-tag">{tech}</span>
              ))}
            </div>
          </div>

          <div class="meta-block">
            <span class="meta-label">Core Systems</span>
            <div class="tech-stack-wrap">
              <span class="tech-tag">Sprite Rendering</span>
              <span class="tech-tag">Euler Physics</span>
              <span class="tech-tag">AABB Collision</span>
              <span class="tech-tag">Event Polling</span>
              <span class="tech-tag">Mouse Drag</span>
            </div>
          </div>

          <div class="meta-block">
            <span class="meta-label">Rendering</span>
            <span class="meta-value">SDL3 hardware-accelerated (Metal/D3D/Vulkan)</span>
          </div>

          <div class="meta-block">
            <span class="meta-label">Physics</span>
            <span class="meta-value">Explicit Euler integration, 1 px/frame² gravity</span>
          </div>

          <div class="meta-block">
            <span class="meta-label">Collision</span>
            <span class="meta-value">AABB via Separating Axis Theorem, O(n²)</span>
          </div>

          <div class="meta-block">
            <span class="meta-label">Target Frame Rate</span>
            <span class="meta-value">60 FPS (16ms fixed delay)</span>
          </div>

          <div class="action-buttons">
            <a href={project.repoUrl} target="_blank" class="action-btn outline">
              <span class="icon" set:html={githubIcon} />
              View Code
            </a>
          </div>

        </aside>

      </div>

    </div>
  </div>
</Layout>