---
import Layout from '../../layout/Layout.astro';
import GitHub from '../../components/icons/GitHub.astro';
import Breadcrumbs from '../../components/Breadcrumbs.astro';
import { getProject } from '../../data/projects';

const project = getProject('Pilly')!;
const siteOrigin = 'https://cristianopinto.com';
const jsonLd = {
  '@context': 'https://schema.org',
  '@type': 'CreativeWork',
  name: project.title,
  description: project.tagline,
  url: `${siteOrigin}/projects/Pilly`,
  author: { '@type': 'Person', name: 'Cristiano Pinto' },
  dateCreated: project.date,
};
---

<Layout title={`${project.title} – Cristiano Pinto`} description={project.tagline} jsonLd={jsonLd}>
  <div class="projects-wrapper back">
      <Breadcrumbs items={[
        { label: 'Home', href: '/' },
        { label: 'Projects', href: '/projects' },
        { label: project.title }
      ]} />
      <header class="detail-header fade-in">
        <a href="/projects" class="back-link">
          <span class="arrow">←</span> Back to Projects
        </a>
        <h1>{project.title}</h1>
        <p class="tagline">{project.tagline}</p>
      </header>

      <div class="content-grid fade-in-delay">
        
        <main class="project-body">
          <!-- <div class="project-hero-image">
             <div class="placeholder-overlay">Sprite Physics Demo with Drag Interaction</div>
          </div> -->

          <div class="text-content">
            <h3>What Is This?</h3>
            <p>
              Pilly is a bare-bones 2D game engine built on SDL3. Sprite rendering, gravity, collision detection, mouse input—nothing fancy, but all written from scratch. The goal was to understand what actually happens between "draw a sprite" and pixels appearing on screen.
            </p>
            <p>
              It's not production-ready. There are known footguns. But that was kind of the point.
            </p>

            <h3>The Rendering Stack</h3>
            <p>
              SDL3 abstracts away the graphics API—Metal on macOS, Direct3D on Windows, Vulkan on Linux. You call <code>SDL_CreateWindowAndRenderer()</code> and get both handles back. From there, it's just <code>SDL_RenderTexture()</code> calls into a command buffer, then <code>SDL_RenderPresent()</code> to flip.
            </p>
            <p>
              I built this on SDL3 specifically, which meant dealing with breaking changes from SDL2: <code>SDL_RenderTexture()</code> instead of <code>SDL_RenderCopy()</code>, new event constant names, type-safe pixel format enums. The upside is floating-point rectangles (<code>SDL_FRect</code>) for sub-pixel positioning if I ever need it.
            </p>

            <h3>Loading Images</h3>
            <p>
              Textures load through STB Image—a single-header library that handles JPEG, PNG, BMP, and TGA. The pipeline goes:
            </p>
            <ol>
              <li><code>stbi_load()</code> gives you raw pixels and a channel count</li>
              <li>Figure out the format: 4 channels → RGBA32, 3 channels → RGB24</li>
              <li>Calculate pitch (bytes per row): <code>width × channels</code></li>
              <li>Wrap pixels in an <code>SDL_Surface</code> (CPU-side)</li>
              <li>Upload to GPU via <code>SDL_CreateTextureFromSurface()</code></li>
              <li>Free the CPU-side stuff immediately—the texture lives in VRAM now</li>
            </ol>
            <p>
              Path resolution uses a fallback array to handle different working directories. First successful load wins.
            </p>

            <h3>Memory: Raw Pointers Everywhere</h3>
            <p>
              Each sprite owns its <code>SDL_Texture*</code> and cleans it up in the destructor. A global <code>std::list&lt;sprite*&gt;</code> holds non-owning pointers for collision checks and rendering.
            </p>
            <p>
              Sprites are stack-allocated in <code>main()</code>, so destruction order is deterministic. But the constructor has a side effect—it pushes <code>this</code> into the sprite list and stores a pointer back to it. That's a dangling pointer waiting to happen if you destroy a sprite mid-loop.
            </p>
            <p>
              I know. It's not great. But I learned exactly why smart pointers and proper lifetime management exist.
            </p>

            <h3>Physics: Euler Integration</h3>
            <p>
              Gravity uses explicit Euler—the simplest possible integration method. Each frame, velocity increases by 1 pixel/frame² if you're above ground. Position updates by accumulated velocity. Hit the floor, velocity resets to zero.
            </p>
            <p>
              No bounce. No energy transfer. No delta time.
            </p>
            <p>
              That last part is the real problem: physics is tied to frame rate. If you're running at 60 FPS, gravity is 1 px/frame². Drop to 30 FPS, and everything falls in slow motion. A proper implementation would multiply by delta time. This one doesn't.
            </p>

            <h3>Collision: AABB</h3>
            <p>
              Collision detection uses axis-aligned bounding boxes with the Separating Axis Theorem (simplified for rectangles). Check four conditions:
            </p>
            <ul>
              <li>Am I entirely left of the target?</li>
              <li>Am I entirely right of it?</li>
              <li>Am I entirely above it?</li>
              <li>Am I entirely below it?</li>
            </ul>
            <p>
              If any of those are true, there's a separating axis and no collision. Otherwise, you're overlapping.
            </p>
            <p>
              The system tests the <em>proposed</em> position before moving—predictive detection. This prevents tunneling through objects but creates "sticky" collision where sprites can't slide along surfaces.
            </p>
            <p>
              Performance is O(n²). Every sprite checks against every other sprite. No quadtree, no spatial hashing. The <code>std::list</code> makes it worse—pointer chasing kills cache locality.
            </p>

            <h3>Input & Events</h3>
            <p>
              SDL's event queue gets drained every frame. Every sprite receives every event—pure broadcast, no filtering. Simple but wasteful for large sprite counts.
            </p>
            <p>
              Mouse dragging tracks the offset between click position and sprite origin, so the sprite doesn't snap to cursor. While dragged, the sprite follows the mouse minus that offset. One quirk: drag updates run on every event poll, even when the mouse hasn't moved.
            </p>

            <h3>Frame Timing</h3>
            <p>
              Timing is just <code>SDL_Delay(16)</code>—a fixed 16ms sleep targeting 60 FPS. This is wrong in multiple ways:
            </p>
            <ul>
              <li>Doesn't account for actual frame time (event processing, collision checks, rendering)</li>
              <li>OS scheduling adds jitter</li>
              <li>Frame rate drops below 60 under any load</li>
            </ul>
            <p>
              The right approach uses <code>SDL_GetPerformanceCounter()</code> to measure elapsed time and apply it to physics. This engine doesn't do that.
            </p>

            <h3>Threading</h3>
            <p>
              Single-threaded. All logic on main thread. SDL's event queue is thread-safe, but I'm not using that. No worker threads for physics or asset loading.
            </p>
            <p>
              The GPU runs in parallel naturally—SDL3's renderer submits commands asynchronously, and <code>SDL_RenderPresent()</code> may block on vsync while the GPU catches up.
            </p>

            <h3>Build System</h3>
            <p>
              CMake handles cross-platform builds. macOS links against Homebrew's ARM64 SDL3. Windows uses a hard-coded path to the MinGW distribution with a post-build step to copy <code>SDL3.dll</code>.
            </p>
            <p>
              The hard-coded paths won't work on anyone else's machine. Should use <code>find_package(SDL3)</code>. Didn't.
            </p>

            <h3>What I'd Do Differently</h3>
            <ul>
              <li><strong>Delta time</strong> — Decouple physics from frame rate</li>
              <li><strong>Spatial partitioning</strong> — Quadtree or grid hash for collision</li>
              <li><strong>Smart pointers</strong> — Or at least proper lifetime tracking</li>
              <li><strong>Sprite batching</strong> — One draw call per texture, not per sprite</li>
              <li><strong>Texture atlas</strong> — Stop loading the same image multiple times</li>
              <li><strong>Async loading</strong> — Don't block main thread on image decode</li>
              <li><strong>Error handling</strong> — Failed loads shouldn't leave sprites in broken states</li>
            </ul>
            <p>
              This project was about learning the hard way. Mission accomplished.
            </p>
          </div>
        </main>

        <aside class="project-sidebar">
          
          <div class="meta-block">
            <span class="meta-label">Role</span>
            <span class="meta-value">{project.role}</span>
          </div>

          <div class="meta-block">
            <span class="meta-label">Timeline</span>
            <span class="meta-value">{project.date}</span>
          </div>

          <div class="meta-block">
            <span class="meta-label">Stack</span>
            <div class="tech-stack-wrap">
              {project.stack.map(tech => (
                <span class="tech-tag">{tech}</span>
              ))}
            </div>
          </div>

          <div class="meta-block">
            <span class="meta-label">Systems</span>
            <div class="tech-stack-wrap">
              <span class="tech-tag">Sprite Rendering</span>
              <span class="tech-tag">Euler Physics</span>
              <span class="tech-tag">AABB Collision</span>
              <span class="tech-tag">Mouse Drag</span>
            </div>
          </div>

          <div class="meta-block">
            <span class="meta-label">Rendering</span>
            <span class="meta-value">SDL3 (Metal / D3D / Vulkan)</span>
          </div>

          <div class="meta-block">
            <span class="meta-label">Physics</span>
            <span class="meta-value">Euler, 1 px/frame², no delta time</span>
          </div>

          <div class="meta-block">
            <span class="meta-label">Collision</span>
            <span class="meta-value">AABB, O(n²)</span>
          </div>

          <div class="action-buttons">
            <a href={project.repoUrl} target="_blank" rel="noopener noreferrer" class="action-btn outline">
              <span class="icon"><GitHub width={20} height={20} /></span>
              View Code
            </a>
          </div>

        </aside>



    </div>
  </div>
</Layout>